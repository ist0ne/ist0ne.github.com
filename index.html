<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>石头记 | Docker、Kubernetes、CI/CD 等技术分享</title>

  
  <meta name="author" content="ist0ne">
  

  
  <meta name="description" content="Docker、Kubernetes、Ceph、Saltstack、OpenStack 等技术分享">
  

  
  <meta name="keywords" content="blog kubernetes k8s docker container ceph salt saltstack openstack kube kubectl helm charts gitlab git">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="石头记">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="石头记" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">石头记</a>
    </h1>
    <p class="site-description">Docker、Kubernetes、CI/CD 等技术分享</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/01/Kubernetes-Update/"><span>Kubernetes 集群升级</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/01/Kubernetes-Update/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-01T08:56:49.000Z">
          2019-07-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p><strong>视频课程地址：</strong><a href="https://www.bilibili.com/video/av49387629?from=search&seid=4418298671230182069" target="_blank" rel="noopener">戳我开始学习</a></p>
</blockquote>
<h2 id="控制平面升级"><a href="#控制平面升级" class="headerlink" title="控制平面升级"></a>控制平面升级</h2><p>只有master节点需要执行如下操作，需要逐节点操作。将集群从当前的v1.14.3升级到v1.15.0。</p>
<p>列出可用的kubeadm软件包</p>
<pre><code>yum list --showduplicates kubeadm --disableexcludes=kubernetes</code></pre><p>安装kubeadm新版本软件包</p>
<pre><code>yum install -y kubeadm-1.15.0-0 --disableexcludes=kubernetes</code></pre><p>确认kubeadm为正确的版本</p>
<pre><code>kubeadm version</code></pre><p>查看升级计划</p>
<pre><code>kubeadm upgrade plan</code></pre><p>升级第一个控制节点</p>
<pre><code>kubeadm upgrade apply v1.15.0</code></pre><p>升级kubelet软件包</p>
<pre><code>yum install -y kubelet-1.15.0-0 kubectl-1.15.0-0 --disableexcludes=kubernetes</code></pre><p>重启kubelet服务</p>
<pre><code>systemctl restart kubelet</code></pre><h2 id="升级第二、三个控制节点"><a href="#升级第二、三个控制节点" class="headerlink" title="升级第二、三个控制节点"></a>升级第二、三个控制节点</h2><p>升级控制节点</p>
<pre><code>kubeadm upgrade node</code></pre><p>升级kubelet、kubectl软件包</p>
<pre><code>yum install -y kubelet-1.15.0-0 kubectl-1.15.0-0 --disableexcludes=kubernetes</code></pre><p>重启kubelet服务</p>
<pre><code>systemctl daemon-reload
systemctl restart kubelet</code></pre><h2 id="升级工作节点"><a href="#升级工作节点" class="headerlink" title="升级工作节点"></a>升级工作节点</h2><p>逐节点升级工作节点</p>
<p>升级kubeadm软件包</p>
<pre><code>yum install -y kubeadm-1.15.x-0 --disableexcludes=kubernetes</code></pre><p>驱逐节点上的pod并标记为不可调度</p>
<pre><code>kubectl drain k8s-s1 --ignore-daemonsets</code></pre><p>升级kubelet、kubectl软件包</p>
<pre><code>yum install -y kubelet-1.15.0-0 kubectl-1.15.0-0 --disableexcludes=kubernetes</code></pre><p>更新kubelet配置文件</p>
<pre><code>kubeadm upgrade node</code></pre><p>重启kubelet服务</p>
<pre><code>systemctl daemon-reload
systemctl restart kubelet</code></pre><p>查看kubelet状态</p>
<pre><code>systemctl status kubelet</code></pre><p>标注节点为可调度</p>
<pre><code>kubectl uncordon k8s-s1</code></pre><p>确定各节点状态为Ready</p>
<pre><code>kubectl get nodes</code></pre><h2 id="从失败状态恢复"><a href="#从失败状态恢复" class="headerlink" title="从失败状态恢复"></a>从失败状态恢复</h2><p>如果 kubeadm upgrade 执行失败，它将尝试执行回滚。因此，如果这种情况发生在第一个 master 身上，那么集群仍然完好无损的可能性很大。你可以再次运行 kubeadm upgrade apply，因为它是幂等的，最终应确保实际状态是你声明的所需状态。你可以使用参数 –force 运行 kubeadm upgrade apply 命令更改运行的集群为 y.y.y –&gt; x.x.x，它可用于从糟糕的状态中恢复过来。</p>
<p>如果 kubeadm upgrade apply 是在其中一个辅助 master 上失败，则仍然有一个正在工作的已经升级的集群，但辅助 master 的状态有些不确定。你将不得不找出哪里出了问题，并手动加入辅助 master。如上所述，有时升级其中一个辅助 master 时，首先等待重新启动的静态 pod 失败，但在一两分钟的暂停后简单地重复该操作时会成功。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/docker/">docker</a><a href="/tags/container/">container</a><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/k8s/">k8s</a><a href="/tags/kubeadm/">kubeadm</a><a href="/tags/kubectl/">kubectl</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2019/07/01/Kubernetes-Update/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/06/30/Kubernetes-Install/"><span>高可用 Kubernetes 集群部署</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/06/30/Kubernetes-Install/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-30T04:09:18.000Z">
          2019-06-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p><strong>视频课程地址：</strong><a href="https://www.bilibili.com/video/av49387629?from=search&seid=4418298671230182069" target="_blank" rel="noopener">戳我开始学习</a></p>
</blockquote>
<h2 id="Kubernetes版本选择"><a href="#Kubernetes版本选择" class="headerlink" title="Kubernetes版本选择"></a>Kubernetes版本选择</h2><p>Kubernetes 1.14是2019年发布的第一个正式版本。新版本有31个增强功能：其中有10个功能进入了生产可用状态，12个进入了beta版本，另外，增加了7个新功能。1.14版本的主题是可扩展性，支持更多Kubernetes工作负载，其中三个主要功能正式推出，以及一个重要的安全功能转向beta。与之前发布的Kubernetes版本相比，1.14版本中的更多功能逐渐稳定，这是大家期望的重要里程碑。</p>
<ul>
<li><strong>生产级别的Windwos节点支持</strong> Kubernetes1.14版本正式支持将Windows节点添加为工作节点，这意味着可以在生产环境使用Windows容器了，使庞大的Windows应用生态系统能够利用Kubernetes平台的强大功能了。</li>
<li><strong>Kubectl的更新</strong> 新版本Kubectl可以使用声明性Resource Config来管理资源。kubectl的文档也从头进行编写，可参考<a href="https://kubectl.docs.kubernetes.io" target="_blank" rel="noopener">文档</a>。</li>
<li><strong>持久化本地Volumes</strong> 本地SSD比远程磁盘能提供更好的性能。对性能要求比较高的数据库和分布式文件系统可以使用久化本地存储。</li>
</ul>
<h2 id="准备节点"><a href="#准备节点" class="headerlink" title="准备节点"></a>准备节点</h2><p>通过kubeadm部署高可用Kubernetes集群有两种架构，一种是将数据平面（etcd集群）和控制平面（Kubernetes控制节点）部署在一起，另一种是分开部署，其中部署在一起可以节省服务器，但是数据平面和控制平面耦合在一起，当一台机器故障时，数据平面和控制平面将同时出现问题。</p>
<p>数据平面和控制平面共用节点：</p>
<p><img src="imgs/201907/kubeadm-ha-topology-stacked-etcd.png" alt="数据平面和控制平面共用节点"></p>
<p>数据平面和控制平面不共用节点：</p>
<p><img src="imgs/201907/kubeadm-ha-topology-external-etcd.png" alt="数据平面和控制平面不共用节点"></p>
<p>我们按照数据平面和控制平面共用节点进行高可用集群的部署。</p>
<h2 id="升级各节点系统"><a href="#升级各节点系统" class="headerlink" title="升级各节点系统"></a>升级各节点系统</h2><p>操作系统我们选择 CentOS 7 最新版（7.6.1810），如果不是最新版，可参考如下升级到最新版。</p>
<p>按如下内容，编辑 /etc/yum.repos.d/CentOS-Base.repo</p>
<pre><code># CentOS-Base.repo
#
# The mirror system uses the connecting IP address of the client and the
# update status of each mirror to pick mirrors that are updated to and
# geographically close to the client.  You should use this for CentOS updates
# unless you are manually picking other mirrors.
#
# If the mirrorlist= does not work for you, as a fall back you can try the
# remarked out baseurl= line instead.
#
#

[base]
name=CentOS-$releasever - Base
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra
baseurl=http://mirrors.163.com/centos/7.6.1810/os/$basearch/
#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

#released updates
[updates]
name=CentOS-$releasever - Updates
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates&amp;infra=$infra
baseurl=http://mirrors.163.com/centos/7.6.1810/updates/$basearch/
#baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

#additional packages that may be useful
[extras]
name=CentOS-$releasever - Extras
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra
baseurl=http://mirrors.163.com/centos/7.6.1810/extras/$basearch/
#baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

#additional packages that extend functionality of existing packages
[centosplus]
name=CentOS-$releasever - Plus
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus&amp;infra=$infra
baseurl=http://mirrors.163.com/centos/7.6.1810/centosplus/$basearch/
#baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</code></pre><p>升级系统并重启</p>
<pre><code>$ yum update -y
$ reboot</code></pre><p>关闭SELinux，编辑 /etc/sysconfig/selinux，设置SELINUX=disabled</p>
<pre><code>$ setenforce 0</code></pre><p>配置内核参数</p>
<pre><code>$ cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
vm.swappiness = 0
EOF
$ sysctl --system</code></pre><p>Kubernetes v1.8+ 要求关闭系统 Swap，请在所有节点利用以下指令关闭：</p>
<pre><code>$ swapoff -a &amp;&amp; sysctl -w vm.swappiness=0

$ vi /etc/fstab
注释swap相关的行</code></pre><p>设置各节点主机名：</p>
<pre><code>hostnamectl set-hostname k8s-m1
hostnamectl set-hostname k8s-m2
hostnamectl set-hostname k8s-m3
hostnamectl set-hostname k8s-s1
hostnamectl set-hostname k8s-s2</code></pre><p>修改hosts，添加如下行：</p>
<pre><code>172.16.10.48 k8s-m001
172.16.10.49 k8s-m002
172.16.10.50 k8s-m003
172.16.10.51 k8s-s001
172.16.10.52 k8s-s002
172.16.10.53 k8s-s002</code></pre><h2 id="配置所有节点加载ipvs相关模块（kube-proxy-使用ipvs模式）"><a href="#配置所有节点加载ipvs相关模块（kube-proxy-使用ipvs模式）" class="headerlink" title="配置所有节点加载ipvs相关模块（kube-proxy 使用ipvs模式）"></a>配置所有节点加载ipvs相关模块（kube-proxy 使用ipvs模式）</h2><p>加载相关内核模块</p>
<pre><code>$ cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt; EOF
#!/bin/bash
modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack_ipv4
EOF

$ chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4</code></pre><p>安装相关软件包</p>
<pre><code>$ yum install -y ipset ipvsadm</code></pre><h2 id="配置ssh-key认证"><a href="#配置ssh-key认证" class="headerlink" title="配置ssh key认证"></a>配置ssh key认证</h2><p>在主节点1上执行生成公钥</p>
<pre><code>$ ssh-keygen</code></pre><p>拷贝 /root/.ssh/id_rsa.pub 内容到主节点2和主节点3上</p>
<pre><code>$ vi /home/centos/.ssh/authorized_keys</code></pre><h2 id="所有节点安装-Docker"><a href="#所有节点安装-Docker" class="headerlink" title="所有节点安装 Docker"></a>所有节点安装 Docker</h2><p>推荐安装 1.13.1, 17.03, 17.06, 17.09, 18.06, 18.09，但是18.09+是未经测试的，不推荐使用。</p>
<p>安装依赖包</p>
<pre><code>$ yum install -y yum-utils \
device-mapper-persistent-data \
lvm2</code></pre><p>添加docker yum仓库</p>
<pre><code>$  yum-config-manager \
--add-repo \
https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p>安装 Docker</p>
<pre><code>yum install -y docker-ce docker-ce-cli containerd.io</code></pre><p>配置 Docker</p>
<pre><code>$ cat &lt;&lt; EOF &gt; /etc/docker/daemon.json
{
&quot;insecure-registry&quot;: [
    &quot;hub.hipstershop.cn&quot;,
    &quot;reg.hipstershop.cn&quot;
],
&quot;registry-mirror&quot;: &quot;https://q00c7e05.mirror.aliyuncs.com&quot;,
&quot;graph&quot;: &quot;/data1/docker&quot;
}
EOF</code></pre><p>启动Docker</p>
<pre><code>systemctl enable docker &amp;&amp; systemctl start docker</code></pre><h2 id="所有节点安装kubeadm-kubelet-and-kubectl"><a href="#所有节点安装kubeadm-kubelet-and-kubectl" class="headerlink" title="所有节点安装kubeadm, kubelet and kubectl"></a>所有节点安装kubeadm, kubelet and kubectl</h2><p>kubelet版本要与待安装的Kubernetes版本相同，否则可能会出现一些难以预料的问题。</p>
<pre><code>$ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF</code></pre><p>通过 yum 安装软件包</p>
<pre><code>yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</code></pre><p>设置开机自动启动kubelet</p>
<pre><code>systemctl enable kubelet.service</code></pre><h2 id="使用kubeadm创建高可用集群（数据平面和控制平面放置到一起）"><a href="#使用kubeadm创建高可用集群（数据平面和控制平面放置到一起）" class="headerlink" title="使用kubeadm创建高可用集群（数据平面和控制平面放置到一起）"></a>使用kubeadm创建高可用集群（数据平面和控制平面放置到一起）</h2><h3 id="创建第一个节点控制节点"><a href="#创建第一个节点控制节点" class="headerlink" title="创建第一个节点控制节点"></a>创建第一个节点控制节点</h3><p>创建配置文件 kubeadm-config.yaml：</p>
<pre><code>apiVersion: kubeproxy.config.k8s.io/v1alpha1
kind: KubeProxyConfiguration
mode: &quot;ipvs&quot;
---
apiVersion: kubeadm.k8s.io/v1beta1
kind: ClusterConfiguration
kubernetesVersion: v1.14.3
apiServer:
    certSANs:
    - &quot;apiserver.hipstershop.cn&quot;
    - &quot;172.16.1.50&quot;
    - &quot;172.16.10.48&quot;
    - &quot;172.16.10.49&quot;
    - &quot;172.16.10.50&quot;
    extraArgs:
        allow-privileged: &quot;true&quot;
        feature-gates: &quot;VolumeSnapshotDataSource=true,CSINodeInfo=true,    CSIDriverRegistry=true&quot;
controlPlaneEndpoint: &quot;apiserver.hipstershop.cn:6443&quot;
etcd:
    local:
        dataDir: /data1/etcd
networking:
    # This CIDR is a Canal default. Substitute or remove for your CNI     provider.
    podSubnet: &quot;10.244.0.0/16&quot;
controllerManager:
    extraArgs:
        address: 0.0.0.0
scheduler:
    extraArgs:
        address: 0.0.0.0
imageRepository: gcr.azk8s.cn/google-containers</code></pre><blockquote>
<p>172.16.1.50 为APIServer的负载均衡IP，6443为负载均衡的端口。如果没有负载均可以通过 HaProxy自行搭建，参见<a href="https://github.com/findsec-cn/k200/raw/master/1.高可用性集群部署/kHaProxy负载均衡配置.md" target="_blank" rel="noopener">HaProxy负载均衡配置</a>。如果公司有硬件负载均衡如f5、Netscaler等可以直接使用；如果在各云平台可以使用各云平台的负载均衡（如阿里云的SLB）。<br>如果你不能直接访问gcr.io，需要设置imageRepository: gcr.azk8s.cn/google-containers。</p>
</blockquote>
<h3 id="初始化第一个节点"><a href="#初始化第一个节点" class="headerlink" title="初始化第一个节点"></a>初始化第一个节点</h3><pre><code>kubeadm init --config=kubeadm-config.yaml
......
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes master has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
https://kubernetes.io/docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

kubeadm join apiserver.hipstershop.com:6443 --token skvqhu.b297uimw0omi26w0 --discovery-token-ca-cert-hash sha256:b3b23ae7aea87baa02eda31f7fdbd2604e4cfa20a9f9c278671816d630f30d22</code></pre><blockquote>
<p>注意：以上(kubeadm join)输出在其他节点加入时会使用，需要妥善保管</p>
</blockquote>
<h3 id="配置网络节点"><a href="#配置网络节点" class="headerlink" title="配置网络节点"></a>配置网络节点</h3><p>在此选择Canal网络组件，其他网络组建见：<a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/</a></p>
<pre><code>$ mkdir -p $HOME/.kube
$ cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
$ chown $(id -u):$(id -g) $HOME/.kube/config

$ kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/canal/rbac.yaml
$ kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/canal/canal.yaml</code></pre><p>等待第一个节点 pod 都变为运行状态</p>
<pre><code>kubectl get pod -n kube-system
NAME                                       READY   STATUS    RESTARTS   AGE
canal-xp9tm                                3/3     Running   0          79s
coredns-86c58d9df4-d62mw                   1/1     Running   0          2m37s
coredns-86c58d9df4-wq26g                   1/1     Running   0          2m37s
etcd-k8s-m1.novalocal                      1/1     Running   0          2m3s
kube-apiserver-k8s-m1.novalocal            1/1     Running   0          115s
kube-controller-manager-k8s-m1.novalocal   1/1     Running   0          2m21s
kube-proxy-t8x22                           1/1     Running   0          2m37s
kube-scheduler-k8s-m1.novalocal            1/1     Running   0          2m12s</code></pre><h3 id="复制证书到其他控制节点"><a href="#复制证书到其他控制节点" class="headerlink" title="复制证书到其他控制节点"></a>复制证书到其他控制节点</h3><pre><code>USER=centos
CONTROL_PLANE_IPS=&quot;172.16.10.49 172.16.10.50&quot;
for host in ${CONTROL_PLANE_IPS}; do
    scp /etc/kubernetes/pki/ca.crt &quot;${USER}&quot;@$host:
    scp /etc/kubernetes/pki/ca.key &quot;${USER}&quot;@$host:
    scp /etc/kubernetes/pki/sa.key &quot;${USER}&quot;@$host:
    scp /etc/kubernetes/pki/sa.pub &quot;${USER}&quot;@$host:
    scp /etc/kubernetes/pki/front-proxy-ca.crt &quot;${USER}&quot;@$host:
    scp /etc/kubernetes/pki/front-proxy-ca.key &quot;${USER}&quot;@$host:
    scp /etc/kubernetes/pki/etcd/ca.crt &quot;${USER}&quot;@$host:etcd-ca.crt
    scp /etc/kubernetes/pki/etcd/ca.key &quot;${USER}&quot;@$host:etcd-ca.key
    scp /etc/kubernetes/admin.conf &quot;${USER}&quot;@$host:
done</code></pre><h3 id="登录第二、三个控制节点移动证书到正确位置"><a href="#登录第二、三个控制节点移动证书到正确位置" class="headerlink" title="登录第二、三个控制节点移动证书到正确位置"></a>登录第二、三个控制节点移动证书到正确位置</h3><pre><code>USER=centos
mkdir -p /etc/kubernetes/pki/etcd
mv /home/${USER}/ca.crt /etc/kubernetes/pki/
mv /home/${USER}/ca.key /etc/kubernetes/pki/
mv /home/${USER}/sa.pub /etc/kubernetes/pki/
mv /home/${USER}/sa.key /etc/kubernetes/pki/
mv /home/${USER}/front-proxy-ca.crt /etc/kubernetes/pki/
mv /home/${USER}/front-proxy-ca.key /etc/kubernetes/pki/
mv /home/${USER}/etcd-ca.crt /etc/kubernetes/pki/etcd/ca.crt
mv /home/${USER}/etcd-ca.key /etc/kubernetes/pki/etcd/ca.key
mv /home/${USER}/admin.conf /etc/kubernetes/admin.conf</code></pre><h3 id="将第二、三个控制节点加入集群"><a href="#将第二、三个控制节点加入集群" class="headerlink" title="将第二、三个控制节点加入集群"></a>将第二、三个控制节点加入集群</h3><blockquote>
<p>注意：加入集群的命令请使用第一个节点安装完成后生生成的命令。</p>
</blockquote>
<pre><code># 在第二个控制节点执行
$ kubeadm join apiserver.hipstershop.cn:6443 --token skvqhu.b297uimw0omi26w0 --discovery-token-ca-cert-hash sha256:b3b23ae7aea87baa02eda31f7fdbd2604e4cfa20a9f9c278671816d630f30d22 --experimental-control-plane
# 在第三个控制节点执行
$ kubeadm join apiserver.hipstershop.cn:6443 --token skvqhu.b297uimw0omi26w0 --discovery-token-ca-cert-hash sha256:b3b23ae7aea87baa02eda31f7fdbd2604e4cfa20a9f9c278671816d630f30d22 --experimental-control-plane</code></pre><h3 id="将从节点加入集群"><a href="#将从节点加入集群" class="headerlink" title="将从节点加入集群"></a>将从节点加入集群</h3><blockquote>
<p>注意：加入集群的命令请使用第一个节点安装完成后生生成的命令。</p>
</blockquote>
<pre><code># 在s1,s2,s3节点执行
$ kubeadm join apiserver.hipstershop.cn:6443 --token skvqhu.b297uimw0omi26w0 --discovery-token-ca-cert-hash sha256:b3b23ae7aea87baa02eda31f7fdbd2604e4cfa20a9f9c278671816d630f30d22</code></pre>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/docker/">docker</a><a href="/tags/container/">container</a><a href="/tags/kubernetes/">kubernetes</a><a href="/tags/k8s/">k8s</a><a href="/tags/kubeadm/">kubeadm</a><a href="/tags/kubectl/">kubectl</a><a href="/tags/helm/">helm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2019/06/30/Kubernetes-Install/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/11/Docker-Compose-PHP-ENV/"><span>Docker Compose 搭建 PHP 开发环境</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/11/Docker-Compose-PHP-ENV/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-11T06:32:23.000Z">
          2018-09-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Docker PHP 可以快速构建基于 Docker 的 PHP 本地开发环境，此套 LNMP 环境同时支持 PHP 5 和 PHP 7。请克隆此项目使用：<a href="https://github.com/ist0ne/docker-php.git" target="_blank" rel="noopener">https://github.com/ist0ne/docker-php.git</a></p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>PHP/FPM 7.2/5.6、Nginx 1.12、Mysql 5.7、Redis 4.0、Memcached 1.5</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">├── add_project.sh  新建项目脚本（Linux）</span><br><span class="line">├── build  镜像构建目录</span><br><span class="line">│   ├── memcached</span><br><span class="line">│   │   └── Dockerfile</span><br><span class="line">│   ├── mysql</span><br><span class="line">│   │   └── Dockerfile</span><br><span class="line">│   ├── nginx</span><br><span class="line">│   │   └── Dockerfile</span><br><span class="line">│   ├── php5</span><br><span class="line">│   │   └── Dockerfile</span><br><span class="line">│   ├── php7</span><br><span class="line">│   │   └── Dockerfile</span><br><span class="line">│   └── redis</span><br><span class="line">│       └── Dockerfile</span><br><span class="line">├── config  服务配置目录</span><br><span class="line">│   ├── mysql</span><br><span class="line">│   │   ├── backup</span><br><span class="line">│   │   ├── config</span><br><span class="line">│   │   │   └── mysql.cnf</span><br><span class="line">│   │   ├── crontabs</span><br><span class="line">│   │   └── docker-entrypoint-initdb.d  数据库初始化脚本目录</span><br><span class="line">│   ├── nginx</span><br><span class="line">│   │   ├── conf.d</span><br><span class="line">│   │   │   ├── bar.example.com.conf</span><br><span class="line">│   │   │   ├── foo.example.com.conf</span><br><span class="line">│   │   │   └── example.com.conf.template</span><br><span class="line">│   │   ├── fastcgi_mysql</span><br><span class="line">│   │   ├── fastcgi_web</span><br><span class="line">│   │   └── nginx.conf</span><br><span class="line">│   ├── php5</span><br><span class="line">│   │   ├── php.ini</span><br><span class="line">│   │   └── php.ini-production</span><br><span class="line">│   ├── php7</span><br><span class="line">│   │   ├── php.ini</span><br><span class="line">│   │   └── php.ini-production</span><br><span class="line">│   └── redis</span><br><span class="line">│       └── redis.conf</span><br><span class="line">├── data 服务数据目录</span><br><span class="line">│   ├── mysql  数据库数据存储目录</span><br><span class="line">│   ├── nginx</span><br><span class="line">│   │   ├── cache  应用缓存目录</span><br><span class="line">│   │   └── data  应用数据目录</span><br><span class="line">│   └── redis  缓存数据目录</span><br><span class="line">├── docker-compose.yml  项目配置文件</span><br><span class="line">├── logs 服务日志目录</span><br><span class="line">│   ├── access  Nginx访问日志目录</span><br><span class="line">│   │   ├── bar.example.com</span><br><span class="line">│   │   │   └── bar.example.com.log</span><br><span class="line">│   │   └── foo.example.com</span><br><span class="line">│   │       └── foo.example.com.log</span><br><span class="line">│   ├── app  应用日志目录</span><br><span class="line">│   │   ├── bar.example.com</span><br><span class="line">│   │   └── foo.example.com</span><br><span class="line">│   └── srv  服务日志目录</span><br><span class="line">│       ├── memcached</span><br><span class="line">│       ├── mysql</span><br><span class="line">│       │   └── error.log</span><br><span class="line">│       ├── nginx</span><br><span class="line">│       │   └── nginx_error.log</span><br><span class="line">│       ├── php5</span><br><span class="line">│       │   └── php_errors.log</span><br><span class="line">│       ├── php7</span><br><span class="line">│       │   └── php_errors.log</span><br><span class="line">│       └── redis</span><br><span class="line">│           └── redis.log</span><br><span class="line">├── README.md</span><br><span class="line">└── webapps  应用代码目录</span><br><span class="line">    ├── bar.example.com</span><br><span class="line">    │   └── htdocs</span><br><span class="line">    │       └── index.php</span><br><span class="line">    └── foo.example.com</span><br><span class="line">        └── htdocs</span><br><span class="line">            └── index.php</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/docker/">docker</a><a href="/tags/container/">container</a><a href="/tags/compose/">compose</a><a href="/tags/develop/">develop</a><a href="/tags/php/">php</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/09/11/Docker-Compose-PHP-ENV/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/10/Docker-Compose/"><span>Docker Compose</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/10/Docker-Compose/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-10T08:24:51.000Z">
          2018-09-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。Compose 定位是 「定义和运行多个 Docker 容器化应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上缓存服务容器，已经后端的数据库服务容器。Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p>Compose 中有两个重要的概念：</p>
<ul>
<li>服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/docker/">docker</a><a href="/tags/container/">container</a><a href="/tags/compose/">compose</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/09/10/Docker-Compose/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/10/Docker-Volume/"><span>Docker 存储</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/10/Docker-Volume/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-10T03:59:34.000Z">
          2018-09-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Docker 为容器提供了两种存放数据的资源：</p>
<ul>
<li>由 Storage Driver 管理的镜像层和容器层</li>
<li>Data Volume</li>
</ul>
<h3 id="Storage-Driver"><a href="#Storage-Driver" class="headerlink" title="Storage Driver"></a>Storage Driver</h3><p><img src="/imgs/201809/docker_image_layer.png" alt="镜像分层结构"></p>
<p>容器由最上面一个可写的容器层，以及若干只读的镜像层组成，容器的数据就存放在这些层中。这样的分层结构最大的特性是 Copy-on-Write：</p>
<ul>
<li>新数据会直接存放在最上面的容器层</li>
<li>修改现有数据会先从镜像层将数据复制到容器层，修改后的数据直接保存在容器层中，镜像层保持不变</li>
<li>如果多个层中有命名相同的文件，用户只能看到最上面那层中的文件</li>
</ul>
<p>分层结构使镜像和容器的创建、共享以及分发变得非常高效，而这些都要归功于 Docker storage driver。正是 storage driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图。</p>
<p>Docker 支持多种 storage driver，有 AUFS、Device Mapper、Btrfs、OverlayFS、VFS 和 ZFS。它们都能实现分层的架构，同时又有各自的特性。对于 Docker 用户来说，具体选择使用哪个 storage driver 是一个难题，不过 Docker 官方给出了一个简单的答案：优先使用 Linux 发行版默认的 storage driver。Docker 安装时会根据当前系统的配置选择默认的 driver。默认 driver 具有最好的稳定性，因为默认 driver 在发行版上经过了严格的测试。</p>
<p><strong>Docker CE on Ubuntu</strong> aufs, devicemapper, overlay2 (Ubuntu 14.04.4 or later, 16.04 or later), overlay, zfs, vfs<br><strong>Docker CE on Debian</strong> aufs, devicemapper, overlay2 (Debian Stretch), overlay, vfs<br><strong>Docker CE on CentOS</strong> devicemapper, vfs<br><strong>Docker CE on Fedora</strong> devicemapper, overlay2 (Fedora 26 or later, experimental), overlay (experimental), vfs</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/docker/">docker</a><a href="/tags/container/">container</a><a href="/tags/volume/">volume</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/09/10/Docker-Volume/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/07/02/Docker-Network/"><span>Docker 网络</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/02/Docker-Network/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-02T06:05:45.000Z">
          2018-07-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="容器的三种本地网络"><a href="#容器的三种本地网络" class="headerlink" title="容器的三种本地网络"></a>容器的三种本地网络</h2><h3 id="none-网络"><a href="#none-网络" class="headerlink" title="none 网络"></a>none 网络</h3><p>故名思议，none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 --network=none 指定使用 none 网络。</p>
<p><img src="/imgs/201807/docker_network_none.png" alt="docker network none"></p>
<h3 id="host-网络"><a href="#host-网络" class="headerlink" title="host 网络"></a>host 网络</h3><p>连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与 host 完全一样。可以通过 --network=host 指定使用 host 网络。使用 host 网络，容器和宿主机共用 host 网络，当启动服务时应该避免端口冲突。</p>
<p><img src="/imgs/201807/docker_network_host.png" alt="docker network host"></p>
<h3 id="Bridge-网络"><a href="#Bridge-网络" class="headerlink" title="Bridge 网络"></a>Bridge 网络</h3><p>Docker 安装时会创建一个命名为 docker0 的 linux bridge。如果不指定--network，创建的容器默认都会挂到 docker0 上。</p>
<p><img src="/imgs/201807/docker_network_bridge.png" alt="docker network bridge"></p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/docker/">docker</a><a href="/tags/container/">container</a><a href="/tags/network/">network</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/07/02/Docker-Network/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/06/22/Run-Docker/"><span>Docker 生命周期管理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/22/Run-Docker/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-22T03:13:58.000Z">
          2018-06-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>docker run 是启动容器的方法，容器启动后返回的是 “长ID”，我们可以通过这个长ID去访问这个容器，也可以通过启动时指定的名字访问这个容器。docker ps 能够看到容器的“短ID”，通过短ID同样可以访问这个容器，甚至只要能够唯一标识这个容器也可使用更短的ID。</p>
<p><img src="/imgs/201806/docker_run.jpg" alt="docker run"></p>
<p>-d 指定容器以后台方式运行；–restart 指定容器的重启策略，默认值no，容器退出时不要重启，on-failure[:max-retries] 只在容器以非0状态码退出时重启。max-retries可以指定尝试重启容器的次数；always 不管退出状态码是什么始终重启容器。当指定容器退出后，docker daemon将无限次数地重启容器。–name 指定容器的名称。</p>
<p>容器的生命周期依赖于启动时执行的命令，只要该命令不结束，容器也就不会退出。理解了这个原理，我们就可以通过执行一个长期运行的命令来保持容器的运行状态。</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/docker/">docker</a><a href="/tags/container/">container</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/06/22/Run-Docker/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/06/11/Docker-Images/"><span>Docker 镜像</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/11/Docker-Images/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-11T06:20:40.000Z">
          2018-06-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="最小镜像"><a href="#最小镜像" class="headerlink" title="最小镜像"></a>最小镜像</h2><p>镜像是 Docker 容器的基石，容器是镜像的实例，有了镜像才能启动容器。</p>
<p>镜像到底包含什么呢？容器为什么是轻量级的虚拟化呢？</p>
<p><img src="/imgs/201806/run_hello_world.png" alt="运行hello world"></p>
<p>首先从一个最小的镜像hello-world讲起，hello-world镜像仅有1.85kB，根据经验它肯定是不包括Linux的内核的，因为现在Linux内核大小至少100MB以上。</p>
<p>这么小的镜像，它能运行，是一个完整的镜像，他是怎么构建出来的呢？</p>
<p><img src="/imgs/201806/dockerfile_hello_world.png" alt="hello world dockerfile"></p>
<p>这个镜像的构建文件仅有三行，第一行从空白镜像开始构建，第二行拷贝二进制hello程序，第三行运行hello程序。</p>
<p>/hello 就是文件系统的全部内容，连最基本的 /bin，/usr, /lib, /dev 都没有。</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/docker/">docker</a><a href="/tags/container/">container</a><a href="/tags/image/">image</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/06/11/Docker-Images/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/06/07/Hello-Docker/"><span>Hello Docker</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/07/Hello-Docker/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-07T10:41:33.000Z">
          2018-06-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="环境选择"><a href="#环境选择" class="headerlink" title="环境选择"></a>环境选择</h2><p>容器需要管理工具、运行时和操作系统，我们的选择如下：</p>
<ul>
<li><p>管理工具 - Docker Engine<br>因为 Docker 最流行使用最广泛</p>
</li>
<li><p>运行时 - runc<br>Docker 的默认 runtime</p>
</li>
<li><p>操作系统 - Ubuntu<br>选择大家熟悉的操作系统</p>
</li>
</ul>
<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>我们将在 ubuntu 16.04 虚拟机中安装 Docker。因为安装过程需要访问 internet， 所以虚拟机必须能够上网。</p>
<p>Docker 支持几乎所有的 Linux 发行版，也支持 Mac 和 Windows。各操作系统的安装方法可以访问：<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">https://docs.docker.com/install/</a></p>
<p>Docker 分为开源免费的 CE（Community Edition）版本和收费的 EE（Enterprise Edition）版本。下面我们将按照文档，通过以下步骤在 Ubuntu 16.04 上安装 Docker CE 版本。</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/docker/">docker</a><a href="/tags/container/">container</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/06/07/Hello-Docker/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/09/10/openstack-use/"><span>Openstack 使用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/09/10/openstack-use/" rel="bookmark">
        <time class="entry-date published" datetime="2014-09-10T03:00:00.000Z">
          2014-09-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>OpenStack作为基础设施即服务（简称IaaS）资源的通用前端。首要任务是简化云的部署过程并为其带来良好的可扩展性。本文希望通过提供必要的指导信息，帮助大家利用OpenStack前端来设置及管理自己的私有云。</p>
<h2 id="导入虚拟机镜像"><a href="#导入虚拟机镜像" class="headerlink" title="导入虚拟机镜像"></a>导入虚拟机镜像</h2><p>如下列出了一下虚拟机镜像，可以在本地下载后通过Openstack界面导入。</p>
<p><a href="https://openstack.redhat.com/Image_resources" target="_blank" rel="noopener">https://openstack.redhat.com/Image_resources</a></p>
<p>也可以参考如下文档自己制作镜像：</p>
<p><a href="https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/OpenStack/page/Creating%20qcow2%20CentOS%20Image%20for%20OpenStack" target="_blank" rel="noopener">https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/OpenStack/page/Creating%20qcow2%20CentOS%20Image%20for%20OpenStack</a></p>
<p>导入镜像：</p>
<p>点击左侧的镜像 选项卡，可以看到已经导入的镜像，点击创建镜像 按钮创建镜像。</p>
<p><img src="/images/14-09-10/openstack_images.png" alt="Openstack镜像"></p>
<p>填写 镜像名称，镜像源选择—镜像文件，格式选择 QCOW2，勾选 公有 框（这样你上传得镜像其他人也能使用），然后点击创建镜像。</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/虚拟化/">虚拟化</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Openstack/">Openstack</a><a href="/tags/KVM/">KVM</a><a href="/tags/Ceph/">Ceph</a><a href="/tags/CoreOS/">CoreOS</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2014/09/10/openstack-use/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 ist0ne
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-39923501-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>